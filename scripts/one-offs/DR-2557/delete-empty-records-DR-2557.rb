# frozen_string_literal: false

# This comes from https://jira.nypl.org/browse/DR-2557

# We have not been great at deleting empty parents from Repo API. There are code changes now deployed to fix that, but we should do some cleanup as well. This script aims to delete any parent containers or collections that have no children. These aren't interesting for our patrons browsing DC.
# Included in this directory are two files with lists of uuids that would be expected to be deleted, generated by running this script earlier but only logging uuids and not deleting them. These can be spot-checked for sanity before running the script. 

# How to run: bundle exec ruby ./scripts/one-offs/DR-2557/delete-empty-records-DR-2557.rb SOLR_URL
# E.g., for dev: bundle exec ruby ./scripts/one-offs/DR-2557/delete-empty-records-DR-2557.rb http://10.225.133.217:8983/solr/repoapi

# Optionally, you can test locally what it will do by adding a second argument, 'test', that prevents updates to solr but still generates files listing what would be deleted if not run in test mode.
# E.g., for dev: bundle exec ruby ./scripts/one-offs/DR-2557/delete-empty-records-DR-2557.rb http://10.225.133.217:8983/solr/repoapi test
# It should run for two hours or less. 

require File.expand_path(File.join(File.dirname(__FILE__), '..', '..', '..', 'config', 'environment'))

# Set up the Solr connection
solr_url = ARGV[0]
test_mode = ARGV[1]
solr = RSolr.connect(timeout: 120, open_timeout: 120, url: solr_url)

csv_file = 'records_deleted_from_solr.csv'

# Set the batch size
batch_size = 500

# Initial offset
offset = 0
CSV.open(csv_file, 'w') do |csv|
  loop do
    # Query for all collection or container records. 
    query = 'type_s:"http://uri.nypl.org/vocabulary/repository_terms#Collection" OR type_s:"http://uri.nypl.org/vocabulary/repository_terms#Container"'
   
    params = {
      q: "#{query}",
      fl: 'uuid',
      rows: batch_size,
      start: offset
    }
    response = solr.get('select', params: params)

    # Extract UUIDs of collection records in this batch
    parent_uuids = response['response']['docs'].map { |doc| doc['uuid'] }

    # If no collection records are found in the batch, break out of the loop
    break if parent_uuids.empty?

    # Loop through each collection record in the batch
    parent_uuids.each do |uuid|
      # Check if the UUID exists in the parentUUID field of other records
      parent_query = "parentUUID:\"#{uuid}\""
      begin
        parent_response = solr.get('select', params: { q: parent_query, rows: 1 })
      rescue Exception => e 
        sleep 3.seconds
        parent_response = solr.get('select', params: { q: parent_query, rows: 1 })
      end

      # If no records contain this UUID, delete the collection record
      if parent_response['response']['numFound'] == 0
        puts "Deleting parent with UUID: #{uuid}"
        csv << [uuid]
        solr.delete_by_id(uuid) if ARGV[1] != 'test'
      else 
        puts "Did not delete #{uuid}"
      end
    end

    # Commit the changes to Solr after processing each batch
    solr.commit if ARGV[1] != 'test'

    # Increment the offset to retrieve the next batch
    offset += batch_size
  end
end

puts "Finished!"